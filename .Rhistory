?popsize
??popsize
devtools::document()
nfolds = 2
N = 10
idfold = rep(1, N)
folds = 1
permutset = sample(1:N, N, replace = FALSE)
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
idfold[permutset[sbset]] = folds
if(nfolds == 1){
List1 = List_matrix
List2 = List1
sbset = 1:N
}else{
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
List1 = List_matrix[permutset[-sbset],]
List2 = List_matrix[permutset[sbset],]
idfold[permutset[sbset]] = folds
}
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
idfold[permutset[sbset]] = folds
idfold
permutset
sbset
permutset[sbset]
idfold[permutset[sbset]]
folds = 2
sbset = ((folds - 1)*ceiling(N/nfolds) + 1):(folds*ceiling(N/nfolds))
sbset = sbset[sbset <= N]
idfold[permutset[sbset]] = folds
idfold
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check_()
devtools::check()
devtools::document()
devtools::check()
class(c(4, 5))
class(c(4))
class(4)
is.integer(c(4, 5))
is.integer(4, 5)
is.integer(4)
is.integer(5)
is.integer(9)
is.integer(90)
is.integer(0)
is.integer(0.9)
?is.integer
1 - round(1)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::build_manual()
devtools::spell_check()
devtools::load_all()
print(list('a', 'k', 55))
devtools::document()
devtools::build_manual()
?devtools::release
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
trace()
traceback()
devtools::document()
traceback()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::build_manual()
devtools::build_manual()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::build_manual()
devtools::build_manual()
devtools::document()
devtools::document()
install.packages("SuperLearner")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::load_all()
lk = simuldata(n = 500, l = 4)$List_matrix
head(lk)
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @import SuperLearner, parallel, janitor
#' @export
qhat_sl <- function (List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005,
sl.lib = c("SL.glm", "SL.gam", "SL.glm.interaction", "SL.ranger", "SL.glmnet"), num_cores = NA,...)
{
stopifnot(ncol(List.train) > K)
require("SuperLearner", quietly = TRUE, warn.conflicts = FALSE)
require("parallel", quietly = TRUE, warn.conflicts = FALSE)
require("gam", quietly = TRUE, warn.conflicts = FALSE)
#require("xgboost", quietly = TRUE, warn.conflicts = FALSE)
require("janitor", quietly = TRUE, warn.conflicts = FALSE)
require("tidyr", quietly = TRUE, warn.conflicts = FALSE)
slib = intersect(sl.lib, c("SL.glm", "SL.gam",
"SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
if(length(slib) == 0){
slib2 = slib1
}else{
slib2 <- c(slib1, slib, split(rbind(slib, "screen.corP"),
rep(1:length(slib), each = 2)), split(rbind(slib, "screen.glmnet"),
rep(1:length(slib), each = 2)))
}
num_cores = min(num_cores, parallel::detectCores() - 1, na.rm = TRUE)
factor_cols <- subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
if(length(factor_cols)) {
List.train = data.frame(List.train[,!(names(List.train) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.train))
List.test = data.frame(List.test[,!(names(List.test) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.test))
}
if (ncol(List.train) == K + 1) {
xtrain = data.frame(x1 = List.train[, K + 1])
xtest = data.frame(x1 = List.test[, K + 1])
} else {
xtrain = List.train[, -c(1:K)]
xtest = List.test[, -c(1:K)]
}
xtrain = janitor::clean_names(xtrain)
xtest = janitor::clean_names(xtest)
if(num_cores == 1){
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(SuperLearner(Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(SuperLearner(Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
}else{
options(mc.cores = num_cores)
getOption("mc.cores")
cl <- parallel::makeCluster(num_cores, type = "PSOCK")
parallel::clusterSetRNGStream(cl, iseed = 2343)
foo <- parallel::clusterEvalQ(cl, library(SuperLearner))
parallel::clusterExport(cl, foo)
fiti = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
parallel::stopCluster(cl)
}
if ("try-error" %in% c(class(fiti), class(fitj), class(fitij))) {
warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}
else {
q12 = pmax(pmin(predict(fitij, newdata = xtest, onlySL = TRUE)$pred,
1), eps)
q1 = pmin(pmax(predict(fiti, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
q2 = pmin(pmax(predict(fitj, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
return(list(q1 = q1, q2 = q2, q12 = q12))
}
}
qhat_sl(List.train = lk, List.test = lk)
??select_if
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @import SuperLearner, parallel, dplyr, janitor
#' @export
qhat_sl <- function (List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005,
sl.lib = c("SL.glm", "SL.gam", "SL.glm.interaction", "SL.ranger", "SL.glmnet"), num_cores = NA,...)
{
stopifnot(ncol(List.train) > K)
require("SuperLearner", quietly = TRUE, warn.conflicts = FALSE)
require("parallel", quietly = TRUE, warn.conflicts = FALSE)
require("gam", quietly = TRUE, warn.conflicts = FALSE)
require("dplyr")
#require("xgboost", quietly = TRUE, warn.conflicts = FALSE)
require("janitor", quietly = TRUE, warn.conflicts = FALSE)
require("tidyr", quietly = TRUE, warn.conflicts = FALSE)
slib = intersect(sl.lib, c("SL.glm", "SL.gam",
"SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
if(length(slib) == 0){
slib2 = slib1
}else{
slib2 <- c(slib1, slib, split(rbind(slib, "screen.corP"),
rep(1:length(slib), each = 2)), split(rbind(slib, "screen.glmnet"),
rep(1:length(slib), each = 2)))
}
num_cores = min(num_cores, parallel::detectCores() - 1, na.rm = TRUE)
factor_cols <- subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
if(length(factor_cols)) {
List.train = data.frame(List.train[,!(names(List.train) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.train))
List.test = data.frame(List.test[,!(names(List.test) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.test))
}
if (ncol(List.train) == K + 1) {
xtrain = data.frame(x1 = List.train[, K + 1])
xtest = data.frame(x1 = List.test[, K + 1])
} else {
xtrain = List.train[, -c(1:K)]
xtest = List.test[, -c(1:K)]
}
xtrain = janitor::clean_names(xtrain)
xtest = janitor::clean_names(xtest)
if(num_cores == 1){
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(SuperLearner(Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(SuperLearner(Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
}else{
options(mc.cores = num_cores)
getOption("mc.cores")
cl <- parallel::makeCluster(num_cores, type = "PSOCK")
parallel::clusterSetRNGStream(cl, iseed = 2343)
foo <- parallel::clusterEvalQ(cl, library(SuperLearner))
parallel::clusterExport(cl, foo)
fiti = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
parallel::stopCluster(cl)
}
if ("try-error" %in% c(class(fiti), class(fitj), class(fitij))) {
warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}
else {
q12 = pmax(pmin(predict(fitij, newdata = xtest, onlySL = TRUE)$pred,
1), eps)
q1 = pmin(pmax(predict(fiti, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
q2 = pmin(pmax(predict(fitj, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
return(list(q1 = q1, q2 = q2, q12 = q12))
}
}
qhat_sl(List.train = lk, List.test = lk)
??negate
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @import SuperLearner, parallel, dplyr, janitor
#' @export
qhat_sl <- function (List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005,
sl.lib = c("SL.glm", "SL.gam", "SL.glm.interaction", "SL.ranger", "SL.glmnet"), num_cores = NA,...)
{
stopifnot(ncol(List.train) > K)
require("SuperLearner", quietly = TRUE, warn.conflicts = FALSE)
require("parallel", quietly = TRUE, warn.conflicts = FALSE)
require("gam", quietly = TRUE, warn.conflicts = FALSE)
require("dplyr")
#require("xgboost", quietly = TRUE, warn.conflicts = FALSE)
require("janitor", quietly = TRUE, warn.conflicts = FALSE)
require("tidyr", quietly = TRUE, warn.conflicts = FALSE)
slib = intersect(sl.lib, c("SL.glm", "SL.gam",
"SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
if(length(slib) == 0){
slib2 = slib1
}else{
slib2 <- c(slib1, slib, split(rbind(slib, "screen.corP"),
rep(1:length(slib), each = 2)), split(rbind(slib, "screen.glmnet"),
rep(1:length(slib), each = 2)))
}
num_cores = min(num_cores, parallel::detectCores() - 1, na.rm = TRUE)
factor_cols <- subset(List.train, select = -c(1:K)) %>% select_if(!(is.numeric)) %>% names()
if(length(factor_cols)) {
List.train = data.frame(List.train[,!(names(List.train) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.train))
List.test = data.frame(List.test[,!(names(List.test) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.test))
}
if (ncol(List.train) == K + 1) {
xtrain = data.frame(x1 = List.train[, K + 1])
xtest = data.frame(x1 = List.test[, K + 1])
} else {
xtrain = List.train[, -c(1:K)]
xtest = List.test[, -c(1:K)]
}
xtrain = janitor::clean_names(xtrain)
xtest = janitor::clean_names(xtest)
if(num_cores == 1){
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(SuperLearner(Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(SuperLearner(Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
}else{
options(mc.cores = num_cores)
getOption("mc.cores")
cl <- parallel::makeCluster(num_cores, type = "PSOCK")
parallel::clusterSetRNGStream(cl, iseed = 2343)
foo <- parallel::clusterEvalQ(cl, library(SuperLearner))
parallel::clusterExport(cl, foo)
fiti = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
parallel::stopCluster(cl)
}
if ("try-error" %in% c(class(fiti), class(fitj), class(fitij))) {
warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}
else {
q12 = pmax(pmin(predict(fitij, newdata = xtest, onlySL = TRUE)$pred,
1), eps)
q1 = pmin(pmax(predict(fiti, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
q2 = pmin(pmax(predict(fitj, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
return(list(q1 = q1, q2 = q2, q12 = q12))
}
}
qhat_sl(List.train = lk, List.test = lk)
negate(1 == 2)
?select_if
subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
List.train = lk
subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
K = 2
subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
subset(List.train, select = -c(1:K)) %>% select_if((is.numeric)) %>% names()
subset(List.train, select = -c(1:K)) %>% select_if(!(is.numeric)) %>% names()
subset(List.train, select = -c(1:K)) %>% select_if(nottem(is.numeric)) %>% names()
subset(List.train, select = -c(1:K)) %>% select_if(Negate(is.numeric)) %>% names()
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @import SuperLearner, parallel, dplyr, janitor
#' @export
qhat_sl <- function (List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005,
sl.lib = c("SL.glm", "SL.gam", "SL.glm.interaction", "SL.ranger", "SL.glmnet"), num_cores = NA,...)
{
stopifnot(ncol(List.train) > K)
require("SuperLearner", quietly = TRUE, warn.conflicts = FALSE)
require("parallel", quietly = TRUE, warn.conflicts = FALSE)
require("gam", quietly = TRUE, warn.conflicts = FALSE)
require("dplyr")
#require("xgboost", quietly = TRUE, warn.conflicts = FALSE)
require("janitor", quietly = TRUE, warn.conflicts = FALSE)
require("tidyr", quietly = TRUE, warn.conflicts = FALSE)
slib = intersect(sl.lib, c("SL.glm", "SL.gam",
"SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
if(length(slib) == 0){
slib2 = slib1
}else{
slib2 <- c(slib1, slib, split(rbind(slib, "screen.corP"),
rep(1:length(slib), each = 2)), split(rbind(slib, "screen.glmnet"),
rep(1:length(slib), each = 2)))
}
num_cores = min(num_cores, parallel::detectCores() - 1, na.rm = TRUE)
factor_cols <- subset(List.train, select = -c(1:K)) %>% select_if(Negate(is.numeric)) %>% names()
if(length(factor_cols)) {
List.train = data.frame(List.train[,!(names(List.train) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.train))
List.test = data.frame(List.test[,!(names(List.test) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.test))
}
if (ncol(List.train) == K + 1) {
xtrain = data.frame(x1 = List.train[, K + 1])
xtest = data.frame(x1 = List.test[, K + 1])
} else {
xtrain = List.train[, -c(1:K)]
xtest = List.test[, -c(1:K)]
}
xtrain = janitor::clean_names(xtrain)
xtest = janitor::clean_names(xtest)
if(num_cores == 1){
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(SuperLearner(Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(SuperLearner(Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
}else{
options(mc.cores = num_cores)
getOption("mc.cores")
cl <- parallel::makeCluster(num_cores, type = "PSOCK")
parallel::clusterSetRNGStream(cl, iseed = 2343)
foo <- parallel::clusterEvalQ(cl, library(SuperLearner))
parallel::clusterExport(cl, foo)
fiti = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
parallel::stopCluster(cl)
}
if ("try-error" %in% c(class(fiti), class(fitj), class(fitij))) {
warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}
else {
q12 = pmax(pmin(predict(fitij, newdata = xtest, onlySL = TRUE)$pred,
1), eps)
q1 = pmin(pmax(predict(fiti, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
q2 = pmin(pmax(predict(fitj, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
return(list(q1 = q1, q2 = q2, q12 = q12))
}
}
qhat_sl(List.train = lk, List.test = lk)
qhat_sl(List.train = lk, List.test = lk, num_cores = 2)
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::build_manual()
