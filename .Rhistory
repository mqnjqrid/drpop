devtools::document()
traceback()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::build_manual()
devtools::build_manual()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::build_manual()
devtools::build_manual()
devtools::document()
devtools::document()
install.packages("SuperLearner")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::load_all()
lk = simuldata(n = 500, l = 4)$List_matrix
head(lk)
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @import SuperLearner, parallel, janitor
#' @export
qhat_sl <- function (List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005,
sl.lib = c("SL.glm", "SL.gam", "SL.glm.interaction", "SL.ranger", "SL.glmnet"), num_cores = NA,...)
{
stopifnot(ncol(List.train) > K)
require("SuperLearner", quietly = TRUE, warn.conflicts = FALSE)
require("parallel", quietly = TRUE, warn.conflicts = FALSE)
require("gam", quietly = TRUE, warn.conflicts = FALSE)
#require("xgboost", quietly = TRUE, warn.conflicts = FALSE)
require("janitor", quietly = TRUE, warn.conflicts = FALSE)
require("tidyr", quietly = TRUE, warn.conflicts = FALSE)
slib = intersect(sl.lib, c("SL.glm", "SL.gam",
"SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
if(length(slib) == 0){
slib2 = slib1
}else{
slib2 <- c(slib1, slib, split(rbind(slib, "screen.corP"),
rep(1:length(slib), each = 2)), split(rbind(slib, "screen.glmnet"),
rep(1:length(slib), each = 2)))
}
num_cores = min(num_cores, parallel::detectCores() - 1, na.rm = TRUE)
factor_cols <- subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
if(length(factor_cols)) {
List.train = data.frame(List.train[,!(names(List.train) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.train))
List.test = data.frame(List.test[,!(names(List.test) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.test))
}
if (ncol(List.train) == K + 1) {
xtrain = data.frame(x1 = List.train[, K + 1])
xtest = data.frame(x1 = List.test[, K + 1])
} else {
xtrain = List.train[, -c(1:K)]
xtest = List.test[, -c(1:K)]
}
xtrain = janitor::clean_names(xtrain)
xtest = janitor::clean_names(xtest)
if(num_cores == 1){
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(SuperLearner(Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(SuperLearner(Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
}else{
options(mc.cores = num_cores)
getOption("mc.cores")
cl <- parallel::makeCluster(num_cores, type = "PSOCK")
parallel::clusterSetRNGStream(cl, iseed = 2343)
foo <- parallel::clusterEvalQ(cl, library(SuperLearner))
parallel::clusterExport(cl, foo)
fiti = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
parallel::stopCluster(cl)
}
if ("try-error" %in% c(class(fiti), class(fitj), class(fitij))) {
warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}
else {
q12 = pmax(pmin(predict(fitij, newdata = xtest, onlySL = TRUE)$pred,
1), eps)
q1 = pmin(pmax(predict(fiti, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
q2 = pmin(pmax(predict(fitj, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
return(list(q1 = q1, q2 = q2, q12 = q12))
}
}
qhat_sl(List.train = lk, List.test = lk)
??select_if
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @import SuperLearner, parallel, dplyr, janitor
#' @export
qhat_sl <- function (List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005,
sl.lib = c("SL.glm", "SL.gam", "SL.glm.interaction", "SL.ranger", "SL.glmnet"), num_cores = NA,...)
{
stopifnot(ncol(List.train) > K)
require("SuperLearner", quietly = TRUE, warn.conflicts = FALSE)
require("parallel", quietly = TRUE, warn.conflicts = FALSE)
require("gam", quietly = TRUE, warn.conflicts = FALSE)
require("dplyr")
#require("xgboost", quietly = TRUE, warn.conflicts = FALSE)
require("janitor", quietly = TRUE, warn.conflicts = FALSE)
require("tidyr", quietly = TRUE, warn.conflicts = FALSE)
slib = intersect(sl.lib, c("SL.glm", "SL.gam",
"SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
if(length(slib) == 0){
slib2 = slib1
}else{
slib2 <- c(slib1, slib, split(rbind(slib, "screen.corP"),
rep(1:length(slib), each = 2)), split(rbind(slib, "screen.glmnet"),
rep(1:length(slib), each = 2)))
}
num_cores = min(num_cores, parallel::detectCores() - 1, na.rm = TRUE)
factor_cols <- subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
if(length(factor_cols)) {
List.train = data.frame(List.train[,!(names(List.train) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.train))
List.test = data.frame(List.test[,!(names(List.test) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.test))
}
if (ncol(List.train) == K + 1) {
xtrain = data.frame(x1 = List.train[, K + 1])
xtest = data.frame(x1 = List.test[, K + 1])
} else {
xtrain = List.train[, -c(1:K)]
xtest = List.test[, -c(1:K)]
}
xtrain = janitor::clean_names(xtrain)
xtest = janitor::clean_names(xtest)
if(num_cores == 1){
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(SuperLearner(Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(SuperLearner(Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
}else{
options(mc.cores = num_cores)
getOption("mc.cores")
cl <- parallel::makeCluster(num_cores, type = "PSOCK")
parallel::clusterSetRNGStream(cl, iseed = 2343)
foo <- parallel::clusterEvalQ(cl, library(SuperLearner))
parallel::clusterExport(cl, foo)
fiti = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
parallel::stopCluster(cl)
}
if ("try-error" %in% c(class(fiti), class(fitj), class(fitij))) {
warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}
else {
q12 = pmax(pmin(predict(fitij, newdata = xtest, onlySL = TRUE)$pred,
1), eps)
q1 = pmin(pmax(predict(fiti, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
q2 = pmin(pmax(predict(fitj, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
return(list(q1 = q1, q2 = q2, q12 = q12))
}
}
qhat_sl(List.train = lk, List.test = lk)
??negate
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @import SuperLearner, parallel, dplyr, janitor
#' @export
qhat_sl <- function (List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005,
sl.lib = c("SL.glm", "SL.gam", "SL.glm.interaction", "SL.ranger", "SL.glmnet"), num_cores = NA,...)
{
stopifnot(ncol(List.train) > K)
require("SuperLearner", quietly = TRUE, warn.conflicts = FALSE)
require("parallel", quietly = TRUE, warn.conflicts = FALSE)
require("gam", quietly = TRUE, warn.conflicts = FALSE)
require("dplyr")
#require("xgboost", quietly = TRUE, warn.conflicts = FALSE)
require("janitor", quietly = TRUE, warn.conflicts = FALSE)
require("tidyr", quietly = TRUE, warn.conflicts = FALSE)
slib = intersect(sl.lib, c("SL.glm", "SL.gam",
"SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
if(length(slib) == 0){
slib2 = slib1
}else{
slib2 <- c(slib1, slib, split(rbind(slib, "screen.corP"),
rep(1:length(slib), each = 2)), split(rbind(slib, "screen.glmnet"),
rep(1:length(slib), each = 2)))
}
num_cores = min(num_cores, parallel::detectCores() - 1, na.rm = TRUE)
factor_cols <- subset(List.train, select = -c(1:K)) %>% select_if(!(is.numeric)) %>% names()
if(length(factor_cols)) {
List.train = data.frame(List.train[,!(names(List.train) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.train))
List.test = data.frame(List.test[,!(names(List.test) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.test))
}
if (ncol(List.train) == K + 1) {
xtrain = data.frame(x1 = List.train[, K + 1])
xtest = data.frame(x1 = List.test[, K + 1])
} else {
xtrain = List.train[, -c(1:K)]
xtest = List.test[, -c(1:K)]
}
xtrain = janitor::clean_names(xtrain)
xtest = janitor::clean_names(xtest)
if(num_cores == 1){
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(SuperLearner(Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(SuperLearner(Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
}else{
options(mc.cores = num_cores)
getOption("mc.cores")
cl <- parallel::makeCluster(num_cores, type = "PSOCK")
parallel::clusterSetRNGStream(cl, iseed = 2343)
foo <- parallel::clusterEvalQ(cl, library(SuperLearner))
parallel::clusterExport(cl, foo)
fiti = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
parallel::stopCluster(cl)
}
if ("try-error" %in% c(class(fiti), class(fitj), class(fitij))) {
warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}
else {
q12 = pmax(pmin(predict(fitij, newdata = xtest, onlySL = TRUE)$pred,
1), eps)
q1 = pmin(pmax(predict(fiti, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
q2 = pmin(pmax(predict(fitj, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
return(list(q1 = q1, q2 = q2, q12 = q12))
}
}
qhat_sl(List.train = lk, List.test = lk)
negate(1 == 2)
?select_if
subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
List.train = lk
subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
K = 2
subset(List.train, select = -c(1:K)) %>% select_if(negate(is.numeric)) %>% names()
subset(List.train, select = -c(1:K)) %>% select_if((is.numeric)) %>% names()
subset(List.train, select = -c(1:K)) %>% select_if(!(is.numeric)) %>% names()
subset(List.train, select = -c(1:K)) %>% select_if(nottem(is.numeric)) %>% names()
subset(List.train, select = -c(1:K)) %>% select_if(Negate(is.numeric)) %>% names()
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_sl(List.train = List.train, List.test = List.test, K = 3, i = 1, j = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @import SuperLearner, parallel, dplyr, janitor
#' @export
qhat_sl <- function (List.train, List.test, K = 2, i = 1, j = 2, eps = 0.005,
sl.lib = c("SL.glm", "SL.gam", "SL.glm.interaction", "SL.ranger", "SL.glmnet"), num_cores = NA,...)
{
stopifnot(ncol(List.train) > K)
require("SuperLearner", quietly = TRUE, warn.conflicts = FALSE)
require("parallel", quietly = TRUE, warn.conflicts = FALSE)
require("gam", quietly = TRUE, warn.conflicts = FALSE)
require("dplyr")
#require("xgboost", quietly = TRUE, warn.conflicts = FALSE)
require("janitor", quietly = TRUE, warn.conflicts = FALSE)
require("tidyr", quietly = TRUE, warn.conflicts = FALSE)
slib = intersect(sl.lib, c("SL.glm", "SL.gam",
"SL.glm.interaction"))
slib1 = setdiff(sl.lib, slib)
if(length(slib) == 0){
slib2 = slib1
}else{
slib2 <- c(slib1, slib, split(rbind(slib, "screen.corP"),
rep(1:length(slib), each = 2)), split(rbind(slib, "screen.glmnet"),
rep(1:length(slib), each = 2)))
}
num_cores = min(num_cores, parallel::detectCores() - 1, na.rm = TRUE)
factor_cols <- subset(List.train, select = -c(1:K)) %>% select_if(Negate(is.numeric)) %>% names()
if(length(factor_cols)) {
List.train = data.frame(List.train[,!(names(List.train) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.train))
List.test = data.frame(List.test[,!(names(List.test) %in% factor_cols)],
model.matrix(formula(paste('~', paste(factor_cols, collapse = '+'))), List.test))
}
if (ncol(List.train) == K + 1) {
xtrain = data.frame(x1 = List.train[, K + 1])
xtest = data.frame(x1 = List.test[, K + 1])
} else {
xtrain = List.train[, -c(1:K)]
xtest = List.test[, -c(1:K)]
}
xtrain = janitor::clean_names(xtrain)
xtest = janitor::clean_names(xtest)
if(num_cores == 1){
fiti = tryCatch(SuperLearner(Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(SuperLearner(Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(SuperLearner(Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
}else{
options(mc.cores = num_cores)
getOption("mc.cores")
cl <- parallel::makeCluster(num_cores, type = "PSOCK")
parallel::clusterSetRNGStream(cl, iseed = 2343)
foo <- parallel::clusterEvalQ(cl, library(SuperLearner))
parallel::clusterExport(cl, foo)
fiti = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,i]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitj = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(List.train[,j]), X = xtrain, family = binomial(),
SL.library = slib2, method = "method.AUC",
verbose = FALSE), silent = TRUE)
fitij = tryCatch(snowSuperLearner(cluster = cl, Y = as.numeric(pmin(List.train[, i], List.train[, j])),
X = xtrain, family = binomial(), method = "method.AUC",
SL.library = slib2, verbose = FALSE), silent = TRUE)
parallel::stopCluster(cl)
}
if ("try-error" %in% c(class(fiti), class(fitj), class(fitij))) {
warning("One or more fits with SuperLearner regression failed.")
return(NULL)
}
else {
q12 = pmax(pmin(predict(fitij, newdata = xtest, onlySL = TRUE)$pred,
1), eps)
q1 = pmin(pmax(predict(fiti, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
q2 = pmin(pmax(predict(fitj, newdata = xtest, onlySL = TRUE)$pred,
q12), 1)
return(list(q1 = q1, q2 = q2, q12 = q12))
}
}
qhat_sl(List.train = lk, List.test = lk)
qhat_sl(List.train = lk, List.test = lk, num_cores = 2)
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::build_manual()
devtools::build_readme()
devtools::document()
devtools::check()
devtools::check()
devtools::load_all()
ps = try(popsize(List_matrix = simuldata(n = 1000, l = 1)$List_matrix, funcname = c("logit", "gam", "mlogit")), silent = TRUE)
class(ps)
test_that("Runs for single covariate", {
ps = try(popsize(List_matrix = simuldata(n = 1000, l = 1)$List_matrix, funcname = c("logit", "gam", "mlogit")), silent = TRUE)
expect_equal(class(ps) == "try-error", FALSE)
expect_equal(sum(sapply(ps, anyNA)), 0)
})
library(testthat)
test_that("Runs for single covariate", {
ps = try(popsize(List_matrix = simuldata(n = 1000, l = 1)$List_matrix, funcname = c("logit", "gam", "mlogit")), silent = TRUE)
expect_equal(class(ps) == "try-error", FALSE)
expect_equal(sum(sapply(ps, anyNA)), 0)
})
test_that("Runs for single covariate with factor column", {
ps = try(popsize(List_matrix = simuldata(n = 1000, l = 1, categorical = TRUE)$List_matrix, funcname = c("logit", "gam", "mlogit", "ranger")), silent = TRUE)
expect_equal(class(ps) == "try-error", FALSE)
expect_equal(sum(sapply(ps, anyNA)), 0)
})
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::test()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::build_manual()
#' @param ... Any extra arguments passed into the function.
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_logit(List.train = List.train, List.test = List.test, K = 3, j = 1, k = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @importFrom stats binomial formula glm model.matrix na.omit predict rnorm sigma var
citation("stats")
#' @param ... Any extra arguments passed into the function.
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_logit(List.train = List.train, List.test = List.test, K = 3, j = 1, k = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @importFrom stats binomial formula glm model.matrix na.omit predict rnorm sigma var
citation("stats::glm")
#' @param ... Any extra arguments passed into the function.
#' @return A list of the marginal and joint distribution probabilities q_1, q_2 and q_12.
#' @examples
#' \dontrun{
#' qhat = qhat_gam(List.train = List.train, List.test = List.test, K = 3, j = 1, k = 2, eps = 0.005)
#' q1 = qhat$q1
#' q2 = qhat$q2
#' q12 = qhat$q12
#' }
#' @import gam
citation("gam")
citation("ranger")
citation("SuperLearner")
@references Eric Polley, Erin LeDell, Chris Kennedy and Mark van der Laan (2021). SuperLearner: Super Learner Prediction. R package version 2.0-28. https://CRAN.R-project.org/package=SuperLearner
devtools::document()
devtools::document()
@seealso SuperLearner::SuperLearner
devtools::document()
devtools::document()
citation("mlogit")
citation("nnet")
devtools::document()
